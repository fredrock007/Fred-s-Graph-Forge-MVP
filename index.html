<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fred's GraphForge MVP</title>
  <style>
    /* (styles unchanged for brevity, keep your existing CSS) */
  </style>
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#0a0f16" />
  <link rel="apple-touch-icon" href="icon-192.png" />
</head>
<body>
  <div class="wrap">
    <!-- (HTML structure unchanged) -->
    <section class="card plot">
      <div id="plot" style="height: calc(100vh - 52px);"></div>
      <div class="watermark">Fred's GraphForge MVP</div>
    </section>
  </div>  <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.2/lib/browser/math.min.js"></script>  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>  <script>
    // ---------- Helpers ----------
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const finite = (v) => Number.isFinite(v) && Math.abs(v) < 1e12;

    function sanitizeExpr(raw){
      if(!raw) return '';
      return raw.replace(/\s+/g,'').replace(/^y=/i,'').replace(/^fx=/i,'');
    }
    function compileFn(expr){
      const e = sanitizeExpr(expr); if(!e) throw new Error('Empty expression');
      const node = math.parse(e); const code = node.compile();
      return (x, angleMode) => {
        const scope = { x: angleMode==='deg' ? (x*Math.PI/180) : x, pi: Math.PI, e: Math.E };
        const val = code.evaluate(scope); return (typeof val === 'number') ? val : NaN;
      };
    }
    function linspace(a,b,n){ const out=new Array(n); const step=(b-a)/(n-1); for(let i=0;i<n;i++) out[i]=a+i*step; return out; }

    function refineRoot(f,a,b,angleMode='rad',tol=1e-7,maxIters=60){
      let fa=f(a,angleMode), fb=f(b,angleMode); if(!finite(fa)||!finite(fb)||fa*fb>0) return null;
      for(let i=0;i<maxIters;i++){
        const m=0.5*(a+b), fm=f(m,angleMode);
        if(!finite(fm)){ a=m; fa=f(a,angleMode); continue; }
        if(Math.abs(fm)<tol || Math.abs(b-a)<tol) return m;
        if(fa*fm<=0){ b=m; fb=fm; } else { a=m; fa=fm; }
      }
      return 0.5*(a+b);
    }
    function stddev(arr){ const xs=arr.filter(finite); if(xs.length===0) return Infinity; const mean=xs.reduce((s,v)=>s+v,0)/xs.length; const v=xs.reduce((s,v)=>s+(v-mean)*(v-mean),0)/xs.length; return Math.sqrt(v); }
    function groupByNear(xs, eps){ xs.sort((a,b)=>a-b); const groups=[]; let cur=[]; for(const x of xs){ if(cur.length===0||Math.abs(x-cur[cur.length-1])<=eps){cur.push(x);} else {groups.push(cur); cur=[x];} } if(cur.length) groups.push(cur); return groups.map(g=>g.reduce((a,b)=>a+b,0)/g.length); }

    // ---------- Analysis ----------
    function analyse(expr, xMin, xMax, N, angleMode, opts){
      const f = compileFn(expr);
      const xs = linspace(xMin, xMax, N);
      const ys = xs.map(x => f(x, angleMode));

      const features = { roots: [], yint: null, turning: [], vasym: [], hasym: [] };

      const y0 = f(0, angleMode); if(finite(y0)) features.yint = { x:0, y:y0 };

      if(opts.showRoots){
        for(let i=0;i<xs.length-1;i++){
          const y1=ys[i], y2=ys[i+1]; if(!finite(y1)||!finite(y2)) continue; if(y1===0){features.roots.push(xs[i]); continue;}
          if(y1*y2<0){ const r=refineRoot(f,xs[i],xs[i+1],angleMode); if(r!==null && finite(f(r,angleMode))) features.roots.push(r); }
        }
        features.roots = groupByNear(features.roots, 1e-4);
      }

      if(opts.showTurning){
        let dnode; try{ dnode = math.derivative(sanitizeExpr(expr), 'x'); }catch{ dnode=null; }
        if(dnode){
          const df=dnode.compile(); const d=(x)=>{ try{return df.evaluate({ x: angleMode==='deg' ? (x*Math.PI/180) : x });}catch{return NaN;} };
          const d2node=math.derivative(dnode,'x'); const d2f=d2node.compile(); const d2=(x)=>{ try{return d2f.evaluate({ x: angleMode==='deg' ? (x*Math.PI/180) : x });}catch{return NaN;} };
          for(let i=0;i<xs.length-1;i++){
            const a=xs[i], b=xs[i+1]; const da=d(a), db=d(b); if(!finite(da)||!finite(db)) continue;
            if(da===0){ const y=f(a,angleMode), s=d2(a); if(finite(y)&&finite(s)) features.turning.push({x:a,y,kind:s>0?'min':'max'}); }
            else if(da*db<0){ const x0=refineRoot((x)=>d(x),a,b,'rad'); if(x0!==null){ const y=f(x0,angleMode), s=d2(x0); if(finite(y)&&finite(s)) features.turning.push({x:x0,y,kind:s>0?'min':'max'}); } }
          }
          const xsTP = groupByNear(features.turning.map(t=>t.x), 1e-4); const uniqueTP=[]; for(const x of xsTP){ let best=null, bestd=Infinity; for(const t of features.turning){ const d=Math.abs(t.x-x); if(d<bestd){bestd=d; best=t;} } if(best) uniqueTP.push(best); } features.turning=uniqueTP;
        }
      }

      if(opts.showAsym){
        const bigXs=[]; for(let i=1;i<xs.length-1;i++){
          const y=ys[i]; if(!Number.isFinite(y) || Math.abs(y)>1e6){ bigXs.push(xs[i]); continue; }
          const yPrev=ys[i-1], yNext=ys[i+1]; if(finite(yPrev)&&finite(yNext)){ const jump=Math.abs(yNext-yPrev); if(jump>1e6) bigXs.push(xs[i]); }
        }
        features.vasym = groupByNear(bigXs, (xMax-xMin)/200);

        const window=Math.max(10, Math.floor(N*0.08));
        const left=ys.slice(0,window).filter(finite); const right=ys.slice(-window).filter(finite);
        if(left.length){ const s=stddev(left); const m=left.reduce((a,b)=>a+b,0)/left.length; if(s<0.15*Math.max(1,Math.abs(m))) features.hasym.push(m); }
        if(right.length){ const s=stddev(right); const m=right.reduce((a,b)=>a+b,0)/right.length; if(s<0.15*Math.max(1,Math.abs(m))) features.hasym.push(m); }
        features.hasym = groupByNear(features.hasym, 1e-2);
      }

      return { xs, ys, f, features };
    }

    function formatNum(v){ if(!Number.isFinite(v)) return '—'; const s = Math.abs(v) >= 1000 ? v.toFixed(2) : Math.abs(v) >= 1 ? v.toFixed(4) : v.toPrecision(6); return (s.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1')); }

    // ---------- UI ----------
    const el = (id)=>document.getElementById(id);
    const plotDiv = el('plot');
    const featuresBox = el('featuresBox');

    function draw(){
      const expr = el('expr').value;
      const xMin = Number(el('xmin').value), xMax = Number(el('xmax').value);
      const N = clamp(Number(el('points').value)|0, 200, 5000);
      const angleMode = el('angleMode').value;
      const opts = { showRoots: el('showRoots').checked, showTurning: el('showTurning').checked, showAsym: el('showAsym').checked, autoY: el('autoY').checked };

      let result; try{ result = analyse(expr, xMin, xMax, N, angleMode, opts); } catch(err){ featuresBox.innerHTML = `<h3>Problem</h3><div style="color:#ffb3c7">${err.message}</div>`; Plotly.purge(plotDiv); return; }

      const { xs, ys, features } = result;
      const traces = [{ x: xs, y: ys.map(y=>finite(y)?y:null), mode:'lines', name:'f(x)', line:{ width:2 } }];
      if(opts.showRoots && features.roots.length){ traces.push({ x: features.roots, y: features.roots.map(()=>0), mode:'markers', name:'x-intercepts', marker:{ size:9, symbol:'x', color:'#f72585' } }); }
      if(features.yint){ traces.push({ x:[0], y:[features.yint.y], mode:'markers', name:'y-intercept', marker:{ size:9, symbol:'circle', color:'#48e0ff' } }); }
      if(opts.showTurning && features.turning.length){ traces.push({ x: features.turning.map(t=>t.x), y: features.turning.map(t=>t.y), mode:'markers', name:'turning point(s)', marker:{ size:10, symbol:'diamond', color:'#4df29a' } }); }

      const shapes = [];
      if(opts.showAsym){
        for(const x of features.vasym){ shapes.push({ type:'line', x0:x, x1:x, y0:-1e6, y1:1e6, xref:'x', yref:'y', line:{ dash:'dot', width:1, color:'#8393a7' } }); }
        for(const y of features.hasym){ shapes.push({ type:'line', x0:xMin, x1:xMax, y0:y, y1:y, xref:'x', yref:'y', line:{ dash:'dot', width:1, color:'#8393a7' } }); }
      }

      const yFinite = ys.filter(finite);
      const yMin = yFinite.length? Math.min(...yFinite) : -10;
      const yMax = yFinite.length? Math.max(...yFinite) : 10;
      const pad = 0.08*(yMax - yMin || 20);

      Plotly.newPlot(plotDiv, traces, {
        paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
        margin:{l:50,r:20,t:10,b:40},
        xaxis:{ gridcolor:'#1e2636', zerolinecolor:'#2b3447' },
        yaxis:{ gridcolor:'#1e2636', zerolinecolor:'#2b3447', range: (el('autoY').checked? undefined : [yMin-pad, yMax+pad]) },
        shapes,
        annotations:[{ text:"Fred's GraphForge MVP", xref:'paper', yref:'paper', x:1, y:0, xanchor:'right', yanchor:'top', showarrow:false, font:{ size:11, color:'rgba(150,210,255,.5)', family:'ui-sans-serif, system-ui' } }]
      }, {displaylogo:false, responsive:true});

      const rlist = features.roots.map(r=>`x = ${formatNum(r)}`).join('<br>') || '—';
      const tp = features.turning.map(t=>`${t.kind}: ( ${formatNum(t.x)} , ${formatNum(t.y)} )`).join('<br>') || '—';
      const vas = features.vasym.map(x=>`x = ${formatNum(x)}`).join('<br>') || '—';
      const has = features.hasym.map(y=>`y = ${formatNum(y)}`).join('<br>') || '—';
      const yint = features.yint ? `( 0 , ${formatNum(features.yint.y)} )` : '—';

      featuresBox.innerHTML = `
        <h3>Detected features</h3>
        <ul>
          <li><strong>y-intercept:</strong> ${yint}</li>
          <li><strong>x-intercepts:</strong><br>${rlist}</li>
          <li><strong>Turning point(s):</strong><br>${tp}</li>
          <li><strong>Vertical asymptote(s):</strong><br>${vas}</li>
          <li><strong>Horizontal asymptote(s):</strong><br>${has}</li>
        </ul>
      `;
    }

    document.getElementById('plotBtn').addEventListener('click', draw);
    draw();
  </script>  <script>
    // Register the service worker for PWA install + offline
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }
  </script>  <!-- (rest of file with sw.js, manifest, icons unchanged) --></body>
</html>
